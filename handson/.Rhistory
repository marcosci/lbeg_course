print("Hello")
a <- c("1")
# Pakete installieren
install.packages("sf")
# Mit Strg + Enter können Zeilen aus dem Editor
# in der Konsole evaluiert werden
print("Hallo LBEG")
# Mit Strg + Enter können Zeilen aus dem Editor
# in der Konsole evaluiert werden
print("Hallo LBEG")
# Mit Strg + Enter können Zeilen aus dem Editor
# in der Konsole evaluiert werden
print("Hallo LBEG")
# Mit Strg + Enter können Zeilen aus dem Editor
# in der Konsole evaluiert werden
print("Hallo LBEG")
## Mit Strg + Enter können Zeilen aus dem Editor ----
# in der Konsole evaluiert werden
print("Hallo LBEG")
# Bitte das spData Paket laden
library(spData)
data(world)
# Bitte das spData Paket laden
library(spData)
data(world)
# Die Hilfe nutzen
?world
force(world)
force(world)
force(world)
library(tidyverse)
library(nycflights13) # enthält den datensatz
flights
library(tidyverse)
library(nycflights13) # enthält den datensatz
flights
as.data.frame(flights)
as_tibble(flights)
#as_tibble(flights)
flights
filter(flights, month == 1, day == 1)
flights %>%
filter(month == 1, day == 1)
filter(flights, month == 11 | month == 12)
filter(flights, month %in% c(11, 12))
# Filtern von Flügen, die unter 2 stunden delay haben bei Start oder Landung
filter(flights, !(arr_delay > 120 | dep_delay > 120))
filter(flights, arr_delay <= 120, dep_delay <= 120)
# Filtern von Flügen, die unter 2 stunden delay haben bei Start oder Landung
filter(flights, (arr_delay > 120 | dep_delay > 120))
# Sortierung von Spalten
# Automatische aufsteigende Sortierung
arrange(flights, year, month, day)
# Absteigende Sortierung mit desc()
arrange(flights, desc(arr_delay))
# Absteigende Sortierung mit desc()
arrange(flights, desc(arr_delay))
# Missing values werden automatisch ans Ende sortiert
df <- tibble(x = c(5, 2, 6, 11, 700, NA))
df
# Missing values werden automatisch ans Ende sortiert
data.frame(x = c(5, 2, 6, 11, 700, NA))
arrange(df, x)
arrange(df, desc(x))
# Selektieren von spezifischen Spalten
select(flights, year, month, day)
flights
1:10
# Selektieren von zusammenhängenden Spalten
select(flights, year:dep_delay)
# Spalten deselektieren
select(flights, -(year:day))
# Umbenennen von Spalten mit select() // neuer name = alter name
select(flights, tail_num = tailnum)
# Exkurs: Umbenennen von Spalten mit rename()
rename(flights, tail_num = tailnum)
iris
# Hilfsfunktionen für select()
select(iris, starts_with("Petal"))
select(iris, ends_with("Length"))
select(iris, contains("etal"))
select(iris, matches(".w.")) # regular expressions
mutate(flights,
gain = arr_delay - dep_delay,
speed = distance / air_time * 60
)
test <- mutate(flights,
gain = arr_delay - dep_delay,
speed = distance / air_time * 60
)
flights_sml <- select(flights,
year:day,
ends_with("delay"),
distance,
air_time
)
flights_sml
# Summarise über eine Spalte
summarise(flights,
delay = mean(dep_delay, na.rm = TRUE)
)
# Summarise über eine Spalte
summarise(flights,
delay = mean(dep_delay)
)
by_day <- group_by(flights, year, month, day)
by_day
summarise(by_day, delay = mean(dep_delay, na.rm = TRUE))
by_day
summarise(by_day, delay = mean(dep_delay, na.rm = TRUE))
flights %>%
group_by(year, month, day)
flights %>%
group_by(year, month, day) %>%
summarise(delay = mean(dep_delay, na.rm = TRUE))
flights %>%
group_by(year, month, day)
flights %>%
group_by(year, month, day) %>%
summarise(delay = mean(dep_delay, na.rm = TRUE))
# Sobald ein missing value im input ist wird auch der output zum missing value.
# Alle Funktionen haben ein na.rm Argument welches missing values vor der Berechnung entfernt.
flights %>%
group_by(year, month, day) %>%
summarise(delay = mean(dep_delay, na.rm = TRUE)) %>%
View()
# Sobald ein missing value im input ist wird auch der output zum missing value.
# Alle Funktionen haben ein na.rm Argument welches missing values vor der Berechnung entfernt.
dep_deley_single_day  <- flights %>%
group_by(year, month, day) %>%
summarise(delay = mean(dep_delay, na.rm = TRUE))
dep_deley_single_day
flights %>%
group_by(dest) %>%
summarise(count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE)) %>%
filter(delay, count > 20, dest != "HNL") %>%
ggplot(mapping = aes(x = dist, y = delay)) +
geom_point(aes(size = count), alpha = 1/3) +
geom_smooth(se = FALSE)
flights
flights %>%
group_by(dest)
flights %>%
group_by(dest) %>%
summarise(count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE))
flights %>%
group_by(dest) %>%
summarise(count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE)) %>%
filter(delay, count > 20, dest != "HNL")
flights %>%
group_by(dest) %>%
summarise(count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE)) %>%
dplyr::filter(delay, count > 20, dest != "HNL")
flights %>%
group_by(dest)
%>%
summarise(count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE))
flights %>%
group_by(dest) %>%
summarise(count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE))
flights %>%
group_by(dest) %>%
summarise(count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE)) %>%
dplyr::filter(delay, count > 20, dest != "ANC")
flights %>%
group_by(dest) %>%
summarise(count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE)) %>%
dplyr::filter(count > 20, dest != "ANC")
flights %>%
group_by(dest) %>%
summarise(count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE)) %>%
dplyr::filter(count > 20, dest != "ANC") %>%
ggplot(mapping = aes(x = dist, y = delay)) +
geom_point(aes(size = count), alpha = 1/3) +
geom_smooth(se = FALSE)
library(nycflights13) # enthält den datensatz
# 1. Datensatz ------------------------------------------------------------
# Der Datensatz beinhaltet alle 336776 Flüge vom Flughafen New York City in 2013
# (source:US Bureau of Transportation Statistics )
#as_tibble(flights)
flights
flights
# e)
flights %>%
group_by(origin) %>%
summarise(mean_delay = mean(dep_delay, na.rm = TRUE))
# d)
mtcars %>%
mutate(
km_per_litre = 0.425 * mpg
)
flights %>%
filter(arr_time > 2399)
flights %>%
select(distance) %>%
arrange(distance)
flights
c("carrier", "tailnum", "origin", "dest")
# c)
flights %>%
select(c("carrier", "tailnum", "origin", "dest"))
# c)
flights %>%
select(carrier, tailnum, origin, dest)
typeof(flights)
class(flights$tailnum)
is.numeric("3")
is.numeric(3)
flights
# d)
as_tibble(mtcars) %>%
mutate(
km_per_litre = 0.425 * mpg
)
as_tibble(mtcars)
flights %>%
group_by(origin)
flights %>%
group_by(origin) %>%
summarise(mean_delay = mean(dep_delay, na.rm = TRUE))
### Kurzer Exkurs: Eigene Funktionen ----
add_ten <- function(input, input2) {
output <- input + 10
return(output)
}
add_ten
add_ten(0)
add_ten(10)
add_ten <- function(input, input2) {
output <- input + 10
return(output)
}
### For Schleifen Iteration ----
x <- c(1, 4, 7)
gc()
add_ten <- function(input, input2) {
output <- input + 10
return(output)
}
add_ten(0)
add_ten(10)
### For Schleifen Iteration ----
x <- c(1, 4, 7)
seq_along(x)
1:x
seq_along(x)
x[1]
x[2]
x[3]
seq_along(x)
for(bodentiefe in seq_along(x)){
print(bodentiefe)
print(add_ten(x[i]))
}
for(bodentiefe in seq_along(x)){
print(bodentiefe)
print(add_ten(x[bodentiefe]))
}
for(bodentiefe in seq_along(x)){
#print(bodentiefe)
print(add_ten(x[bodentiefe]))
}
add_ten(x[1])
add_ten(x[1])
add_ten(x[2])
add_ten(x[3])
for(bodentiefe in seq_along(x)){
print(add_ten(x[bodentiefe]))
}
seq_along(x)
x
x[1]
seq_along(x)
seq_along(x)
torf_results <- c()
torf_results
for(zeitreihe in seq_along(x)){
torf_results[zeitreihe] <- add_ten(x[zeitreihe])
print(add_ten(x[zeitreihe]))
}
### For Schleifen Iteration ----
x <- c(1, 4, 7)
add_ten(x[1])
add_ten(x[2])
### Kurzer Exkurs: Eigene Funktionen ----
add_ten <- function(input, input2) {
output <- input + 10
return(output)
}
for(zeitreihe in seq_along(x)){
torf_results[zeitreihe] <- add_ten(x[zeitreihe])
print(add_ten(x[zeitreihe]))
}
torf_results
for(zeitreihe in seq_along(x)){
#torf_results[zeitreihe] <- add_ten(x[zeitreihe])
print(add_ten(x[zeitreihe]))
}
torf_results <- c()
seq_along(x)
torf_results$date <- x
torf_results$date
torf_results
torf_results <- c()
for(zeitreihe in seq_along(x)){
torf_results[zeitreihe] <- add_ten(x[zeitreihe])
#print(add_ten(x[zeitreihe]))
}
torf_results
x
### For Schleifen Iteration ----
x <- c(1950, 1951, 1952)
for(zeitreihe in seq_along(x)){
torf_results[zeitreihe] <- add_ten(x[zeitreihe])
#print(add_ten(x[zeitreihe]))
}
torf_results
x
y <- c(50, 30, 70)
for(zeitreihe in seq_along(x)){
torf_results[zeitreihe] <- add_ten(y[zeitreihe])
#print(add_ten(x[zeitreihe]))
}
torf_results
x
library(tidyverse)
### Kurzer Exkurs: Eigene Funktionen ----
add_ten <- function(input, input2) {
output <- input + 10
return(output)
}
add_ten <- function(input, input2) {
output <- input + 10
return(output)
}
### For Schleifen Iteration ----
jahr      <- c(1950, 1951, 1952)
torftiefe <- c(50, 30, 70)
### Kurzer Exkurs: Eigene Funktionen ----
minus_ten <- function(input, input2) {
output <- input - 10
return(output)
}
seq_along(jahr)
torftiefe
torf_results <- c()
for(zeitpunkt in seq_along(jahr)){
torf_results[zeitpunkt] <- minus_ten(torftiefe[zeitpunkt])
}
torf_results
seq_along(jahr)
zeitpunkt <- 1
torf_results[zeitpunkt] <- minus_ten(torftiefe[zeitpunkt])
torf_results
torf_results <- c()
torf_results[zeitpunkt] <- minus_ten(torftiefe[zeitpunkt])
torf_results
zeitpunkt <- 2
torf_results[zeitpunkt] <- minus_ten(torftiefe[zeitpunkt])
torf_results
zeitpunkt <- 3
seq_along(jahr)
zeitpunkt <- 3
torf_results[zeitpunkt] <- minus_ten(torftiefe[zeitpunkt])
torf_results
seq_along(jahr)
map(.x = c(1, 4, 7),
.f = add_ten)
map_int(.x = c(1, 4, 7),
.f = add_ten)
map_dbl(.x = c(1, 4, 7),
.f = add_ten)
# Glücklicherweise müssen wir nicht alles ausschreiben:
map(c(1, 4, 7), add_ten)
c(1, 4, 7)
list(1, 4, 7)
# Egal welche Datenstruktur wir map übergeben, wir bekommen eine Liste zurück:
map(list(1, 4, 7), add_ten)
# Egal welche Datenstruktur wir map übergeben, wir bekommen eine Liste zurück:
map_dbl(list(1, 4, 7), add_ten)
# Glücklicherweise müssen wir nicht alles ausschreiben:
map_dbl(c(1, 4, 7), add_ten)
map(data.frame(a = 1, b = 4, c = 7), add_ten)
data.frame(a = 1, b = 4, c = 7)
map(data.frame(a = 1, b = 4, c = 7), add_ten)
## purrr erlaubt den Rückgabewert selbst zu bestimmen:
map_dbl(c(1, 4, 7), add_ten) # map to a double
map_chr(c(1, 4, 7), add_ten) # map to a character
map_chr(c(1L, 4L, 7L), add_ten) # map to a character
4L
c(1, 4, 7)
## Wir können auch einen tibble mit den alten und neuen Werten erzeugen:
map_df(c(1, 4, 7), function(x) {
return(tibble(old_number = x,
new_number = add_ten(x)))
})
## tilde-dot Abkürzung für Funktionen:
map_dbl(c(1, 4, 7), ~{.x + 10})
####
# Recap Listen & Praktische Beispiele mit purrr
####
library(repurrrsive)
sw_people
# Wie viele Leute sind in unserem Datensatz?
length(sw_people)
length(jahr)
sw_people[[1]]
sw_people[[1]]
# Eine Liste in einer Liste ...
sw_people[1]
sw_people
map(sw_people, ~ length(.x$starships))
sw_people
# Auf wie vielen Schiffen war jeder der Charaktere?
map(sw_people, ~ length(.x$starships))
sw_people
# Wir benennen jedes Listenelement nach seinem Charakter
sw_people <- sw_people %>% set_names(map_chr(sw_people, "name"))
sw_people
# ... und wiederholen:
map(sw_people, ~ length(.x[["starships"]]))
map_int(sw_people, ~ length(.x[["starships"]]))
# Ist der Charakter männlich?
map(sw_people, ~ .x[["gender"]] == "male")
sw_people
# Wie viel wiegt jeder Charakter?
map(sw_people, ~ .x[["mass"]])
map_dbl(sw_people, ~ .x[["mass"]])
map_chr(sw_people, ~ .x[["mass"]])
# Welcher der Star Wars Filme hat die meisten Charaktere?
map(sw_films, "characters") %>%
map_int(length) %>%
set_names(map_chr(sw_films, "title")) %>%
sort()
